# #

define flow logging_flow_named_positional_formatting
flow
	use tremor::pipelines;
	use tremor::connectors;
	define connector read_file from file
	args
		file = "in"#_named_&_positional"
	with
		codec = "json-sorted",
		preprocessors = ["separate"],
		config = {
				"path": args.file,
				"mode": "read"
		},
	end;
	define connector write_file from file
	args
		file = "out"
	with
		codec = "json-sorted",
		postprocessors = ["separate"],
		config = {
				"path": args.file,
				"mode": "truncate"
		},
	end;

	define pipeline logging_pipeline
	pipeline
		use tremor::logging;
		select match event of
			case %{absent level} => "exit"
			case %{absent  msg } => "exit"
			case %{absent data } => # All these cases should only fail if msg await for formatting
				match event of
					case %{level == "DEBUG"} => logging::debug(event.msg)
					case %{level == "ERROR"} => logging::error(event.msg)
					case %{level == "INFO" } => logging::info (event.msg)
					case %{level == "TRACE"} => logging::trace(event.msg)
					case %{level == "WARN" } => logging::warn (event.msg)
					default => "exit"
				end
			default              => # All formatting cases
				match event of
					case %{level == "DEBUG"} => logging::debug(event.msg, event.data)
					case %{level == "ERROR"} => logging::error(event.msg, event.data)
					case %{level == "INFO" } => logging::info (event.msg, event.data)
					case %{level == "TRACE"} => logging::trace(event.msg, event.data)
					case %{level == "WARN" } => logging::warn (event.msg, event.data)
					default => "exit"
				end
		end
		from in into out;
	end;

	# define connector logging from logs;
	define connector logging from logs;
	create connector logging; 
	create connector console from connectors::console;

	# Create read/write file connectors
	create connector reader from read_file;
	create connector writer from write_file;

	# Create pipelines
	create pipeline passthrough from pipelines::passthrough;
	create pipeline logging_pipeline;
	create connector exit from connectors::exit;

	#Connection
	connect /connector/logging to /pipeline/logging_pipeline;
	connect /pipeline/logging_pipeline to /connector/exit;
	
	connect /connector/reader to /pipeline/logging_pipeline;
	connect /pipeline/logging_pipeline to /connector/writer;
end;


define flow logging_flow_varargs_formatting
flow
	use tremor::pipelines;
	use tremor::connectors;
	define connector read_file from file
	args
		file = "in_varargs"
	with
		codec = "json-sorted",
		preprocessors = ["separate"],
		config = {
				"path": args.file,
				"mode": "read"
		},
	end;
	define connector write_file from file
	args
		file = "out"
	with
		codec = "json-sorted",
		postprocessors = ["separate"],
		config = {
				"path": args.file,
				"mode": "truncate"
		},
	end;

	define pipeline logging_pipeline
	pipeline
		use tremor::logging;
		select match event of
			case %{level == "DEBUG"} => logging::debug(event.msg, event.arg1, event.arg2, event.arg3, event.arg4, event.arg5)
			case %{level == "ERROR"} => logging::error(event.msg, event.arg1, event.arg2, event.arg3, event.arg4, event.arg5)
			case %{level == "INFO" } => logging::info (event.msg, event.arg1, event.arg2, event.arg3, event.arg4, event.arg5)
			case %{level == "TRACE"} => logging::trace(event.msg, event.arg1, event.arg2, event.arg3, event.arg4, event.arg5)
			case %{level == "WARN" } => logging::warn (event.msg, event.arg1, event.arg2, event.arg3, event.arg4, event.arg5)
			default => "exit"
		end
		from in into out;
	end;

	# define connector logging from logs;
	define connector logging from logs;
	create connector logging; 
	create connector console from connectors::console;

	# Create read/write file connectors
	create connector reader from read_file;
	create connector writer from write_file;

	# Create pipelines
	create pipeline passthrough from pipelines::passthrough;
	create pipeline logging_pipeline;
	create connector exit from connectors::exit;

	#Connection
	connect /connector/logging to /pipeline/logging_pipeline;
	connect /pipeline/logging_pipeline to /connector/exit;
	
	connect /connector/reader to /pipeline/logging_pipeline;
	connect /pipeline/logging_pipeline to /connector/writer;
end;


deploy flow logging_flow_named_positional_formatting;
#deploy flow logging_flow_varargs_formatting;
